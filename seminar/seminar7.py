# Задача №47.У вас есть код, который вы не можете менять (так часто бывает, когда код в глубине
# программы используется множество раз и вы не хотите ничего сломать):


# transformation = lambda x: x
# values = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] # или любой другой список
# transormed_values = list(map(transformation, values))

# if values == transormed_values:
#     print("ok")
# else:
#     print("fail")


# Задача №49. Планеты вращаются вокруг звезд по эллиптическим орбитам.Назовем самой далекой планетой ту, орбита которой имеет
# самую большую площадь. Напишите функцию find_farthest_orbit(list_of_orbits), которая среди списка орбит
# планет найдет ту, по которой вращается самая далекая планета. Круговые орбиты не учитывайте: вы знаете, что у
# вашей звезды таких планет нет, зато искусственные спутники были были запущены на круговые орбиты. Результатом
# функции должен быть кортеж, содержащий длины полуосей эллипса орбиты самой далекой планеты. Каждая орбита
# представляет из себя кортеж из пары чисел - полуосей ее эллипса. Площадь эллипса вычисляется по формуле S = pi*a*b,
# где a и b - длины полуосей эллипса. При решении задачи используйте списочные выражения. Подсказка: проще всего
# будет найти эллипс в два шага: сначала вычислить самую большую площадь эллипса, а затем найти и сам эллипс,
# имеющий такую площадь. Гарантируется, что самая далекая планета ровно одна



# orbits = [(1, 3), (2.5, 10), (7, 2), (6, 6), (4, 3)]
# def find_farthest_orbit(list_of_orbits):
#     s = [3.14 * a * b for a , b in list_of_orbits if a != b]
#     return list_of_orbits[s.index(max(s))]
# print(*find_farthest_orbit(orbits))


# import random

# planets = [(random.randint(1, 10),(random.randint(1, 10))) for _ in range(10)]
# print(planets)
# planets = list(filter(lambda x: x[0] != x[1], planets))
# print(planets)
# planets_w = list(map(lambda x: x[0] * x[1], planets))
# planets = list(zip(planets, planets_w))
# print(planets)
# print(max(planets, key = lambda x: x[1])[0])

# Задача №51. Напишите функцию same_by(characteristic, objects), которая проверяет, все ли объекты имеют одинаковое значение
# некоторой характеристики, и возвращают True, если это так. Если значение характеристики для разных объектов
# отличается - то False. Для пустого набора объектов, функция должна возвращать True. Аргумент characteristic - это
# функция, которая принимает объект и вычисляет его характеристику.

# def same_by(characteristic, objects: list):
#     return len(set(map(characteristic, objects))) < 2
# lst = ["222", "23445"]
# print(same_by(len, lst))
